#!/bin/bash

shopt -s extglob

# tender vittles
_sysconfdir=/etc
_sharedir=.
builderdir=${_sharedir}/builders
baseconfig=${_sysconfdir}/geninit.conf
carch=$(uname -m)
kernver=$(uname -r)

# Alter PATH. We want to make sure that /bin and /sbin are favored, since
# we specifically rely on GNU coreutils
PATH=/sbin:/bin:$PATH

# error codes
ENOENT=2
EACCES=13
EEXIST=17
EINVAL=22

# globals
declare -i automods=0
declare -i savebuildroot=0
declare basedir=
declare config=
declare imagename=
declare preset=
declare skipbuilders=
declare ocompress=
declare dryrun=

# -------------------------- #
##  general util functions  ##
# -------------------------- #

err() { # {{{
  printf 'error: %s\n' "$*"
} >&2 # }}}

info() { # {{{
  printf ':: %s\n' "$*"
} # }}}

die() { # {{{
  err "$*"
  cleanup 1
} # }}}

in_array() { # {{{
  local item needle=$1; shift
  [[ -z $1 ]] && return 1 # Not Found

  for item; do
    [[ $item = $needle ]] && return 0 # Found
  done
  return 1 # Not Found
} # }}}

qgrep() { # {{{
  2>/dev/null grep -q "$@"
} # }}}

kmodinfo() { # {{{
  modinfo -0k $kernver "$@"
} # }}}

cleanup() { # {{{
  if (( savebuildroot )); then
    info "buildroot preserved at: $buildroot"
  else
    rm -rf "$tmpdir"
  fi
  exit $1
} # }}}

usage() { # {{{
  cat<<USAGE
geninit
Usage: geninit [options]

  Options:
   -b <path>      Use base directory (default: /)
   -c <file>      Specify a different config file (default: $_sysconfdir/geninit.conf)
   -g <path>      Path and name of generated image (dry-run if unspecified)
   -h             Display this help message
   -k <kver>      Specify a different kernel version (default: $(uname -r))
   -p <preset>    Build using a preset file
   -S <names>     Skip the specified builders during the build process
   -s             Preserve buildroot after image creation
   -z <method>    Override compression method

USAGE
  exit
} # }}}

# --------------- #
##  private API  ##
# --------------- #

__add_file() { # {{{
  # add a file to $buildroot
  #   $1: pathname on initcpio
  #   $2: source on disk
  #   $3: mode

  (( $# == 3 )) || return $EINVAL
  [[ -e $buildroot$1 ]] && return $EEXIST

  install -Dm$3 "$2" "$buildroot$1"
} # }}}

__add_dir() { # {{{
  # add a directory (with parents) to $buildroot
  #   $1: pathname on initcpio
  #   $2: mode

  (( $# == 2 )) || [[ $1 == /?* ]] || return $EINVAL
  [[ -e $buildroot$1 ]] && return $EEXIST

  install -dm$2 "$buildroot$1"
} # }}}

__add_slink() { # {{{
  # add a symlink to $buildroot
  #   $1: name on initcpio
  #   $2: target of $1

  (( $# == 2 )) || return $EINVAL
  [[ -L $buildroot$1 ]] && return $EEXIST

  ln -s "$2" "$buildroot$1"
} # }}}

__add_pipe() { # {{{
  # add a pipe to $buildroot
  #   $1: pathname on initcpio
  #   $2: mode

  (( $# == 2 )) || return $EINVAL
  [[ -e $buildroot$1 ]] && return $EEXIST

  mkfifo -m$2 "$buildroot$1"
} # }}}

__build_image() { # {{{
  local -i modcount=0
  local -a zopts pipesave
  local builder= module= line= mod= file=

  # this must be resolved to an absolute path
  if [[ ${imagename:0:1} != / ]]; then
    imagename=$(readlink -f "$imagename")
  fi

  # make sure readlink didn't fail
  [[ $imagename ]] || die "Failed to resolve path to imagename"

  # parse builder array
  for builder in "${builders[@]}"; do
    in_array "$builder" "${skipbuilders[@]}" && continue

    if [[ ! -f $builderdir/$builder ]]; then
      err "cannot find builder '$builder': No such file"
      continue
    fi

    # subshell to prevent namespace pollution
    . "$builderdir/$builder"
    if ! type -t build >/dev/null; then
      err "no build function found in builder '$builder'"
      continue
    fi

    info "Building: [$builder]"
    build
  done

  # add extra modules from config
  for mod in ${modules[@]}; do
    add_module "$mod" || err "Module not found: $mod"
  done

  # add extra files from config
  for file in "${files[@]}"; do
    add_file "$file" || err "File not found: $file"
  done

  # only create depmod files if there's modules added
  if [[ -d $buildroot$moduledir ]]; then
    info "Generating module dependencies"
    depmod -b "$buildroot" "$kernver"
    # trim excess depmod files
    rm "$buildroot$moduledir"/modules.!(dep|alias|symbols)
  fi

  { # create delicious config
    printf '%s %d' '%MODULES%' "${#modules[*]}"
    printf ' %s' "${modules[@]}"
    printf '\n'

    printf '%s' '%HOOKS%'
    printf ' %s' "${builders[@]}"
    printf '\n'
  } > "$buildroot/config"

  if (( dryrun )); then
    info "Dry run complete. Use -g <path> to create an initramfs."
    return
  fi

  if [[ $compress != cat ]]; then
    zopts=('-9')
    [[ $compress = xz ]] && zopts+=('--check=crc32')
  fi

  info "Creating$([[ $compress = cat ]] || printf " $compress") initramfs: $imagename"

  pushd "$buildroot" &>/dev/null
  find . -print0 | cpio -0oH newc | "$compress" "${zopts[@]}" > "$imagename"
  popd &>/dev/null

  pipesave=("${PIPESTATUS[@]}") # save immediately
  (( pipesave[0] )) && die "failed to create filelist (find reported error)"
  (( pipesave[1] )) && die "failed to create cpio archive (cpio reported error)"
  (( pipesave[2] )) && die "$compress reported error compressing image"

  info "Image creation completed successfully"

} # }}}

__build_preset() { # {{{
  local preset= presetfile=$_sysconfdir/geninit.d/$1.preset
  local var= cfg= opts= imagename=
  local -a presets

  if [[ ! -f $basedir$presetfile ]]; then
    err "preset not found: $1"
    return $ENOENT
  fi

  if ! . "$basedir$presetfile"; then
    err "failed to read preset: $1"
    return $EACCES
  fi

  # preset pulls in a known array 'presets'
  for preset in "${presets[@]}"; do
    # resolve kernel version
    if [[ -z $ALL_kver ]]; then
      err "No kernel version defined for preset \`$1'"
      return $EINVAL
    fi

    # resolve image name
    var=${preset}_image
    if [[ -z ${!var} ]]; then
      err "No imagename defined for preset \`$1'"
      return $EINVAL
    fi
    imagename=${!var}

    # extra config
    var=${preset}_config
    if [[ -z ${!var} ]]; then
      # fallback on $ALL_config if its available
      cfg=${ALL_config:-$_sysconfigdir/geninit.conf}
    else
      cfg=${!var}
    fi

    # extra options are optional
    var=${preset}_options
    opts=${!var}

    # this should always resolve to something (i hope)
    if [[ ! -f $basedir$cfg ]]; then
      err "preset config file not found: \`$basedir$cfg'"
      return $ENOENT
    fi

    # we've got enough to relaunch geninit now
    # TODO: don't relaunch. Do this the sane way.
    info "Building image from preset: $1-$preset"
    printf '  ==> %s\n' "-k $ALL_kver -c $cfg -g $basedir$imagename $opts"
    "$0" -b "$basedir" -k "$ALL_kver" -c "$cfg" -g "$basedir$imagename" $opts || return 1
    echo
  done
} # }}}

# its a trap!
trap 'cleanup 130' SIGINT
trap 'cleanup 143' SIGTERM

# source public API
. "$_sharedir/geninit.api"

# source module quirks file
. "$_sharedir/geninit.quirks"

# ------------------ #
##  option parsing  ##
# ------------------ #

while getopts ':b:c:g:hk:Mp:S:sz:' flag; do
  case $flag in
    b) basedir=$OPTARG ;;
    c) config=$OPTARG ;;
    g) imagename=$OPTARG ;;
    h) usage ;;
    k) kernver=$OPTARG ;;
    M) automods=1 ;;
    p) preset=$OPTARG ;;
    S) skipbuilders=(${OPTARG//,/ }) ;;
    s) savebuildroot=1 ;;
    z) ocompress=$OPTARG ;; # named differently to allow overriding
    :) die "option requires an argument -- '$OPTARG'" ;;
   \?) die "invalid option -- '$OPTARG'" ;;
  esac
done

# ----------------- #
##  sanity checks  ##
# ----------------- #

# declared as an array to force expansion. would be great if arch had
# symlink pointing to this from /lib/ld.so
ld_so=($basedir/lib/ld-linux-${carch//_/-}.so.?*)
if (( ${#ld_so[*]} != 1 )); then # uh oh...
  die "failed to resolve the location of /lib/ld.so. Please report this bug."
fi

# make sure our config exists, and source it
config=${config:-$baseconfig}
[[ ! -f $config ]] && die "failed to find config file: \`$config'" || . "$config"

# if specified, does the basedir exist? trim any trailing slash
if [[ $basedir ]]; then
  basedir=${basedir%/}
  [[ -d $basedir ]] || die "basedir \`$basedir' not found"
fi

# does the kernel exist inside the basedir?
[[ -d $basedir/lib/modules/$kernver ]] || die "kernel \`$kernver' not found"

# is our supplied compression method (if supplied) valid?
compress=${ocompress:-$compress}
if [[ -z $compress || $compress = none ]]; then
  compress=cat  # NOOP compressor
else
  [[ $compress = @(gzip|bzip2|lzma|xz) ]] || die "unknown compression method: $compress"
  type -P "$compress" >/dev/null || die "failed to find \`$compress' binary in PATH"
fi

# if $imagename is provided, its path needs to be valid
if [[ $imagename ]]; then
  imagepath=$(readlink -f "$imagename")
  [[ $imagepath ]] || die "invalid path to imagename: $imagename"
  [[ -w ${imagepath%/*} ]] || die "no permission to write to specified path: \`${imagepath%/*}'"
else # no $imagename, so we're doing a dry run
  dryrun=1
fi

# ------------ #
##  int main  ##
# ------------ #

# define a few paths for convenience
tmpdir=$(mktemp -d /tmp/${0##*/}.XXXXXX)
buildroot=$tmpdir/root
autodetect_cache=$tmpdir/autodetect.cache
moduledir=/lib/modules/$kernver

if (( automods )); then
  . "$_sharedir/builders/autodetect" || die "unable to source autodetect builder"
  build
  info "Autodetected modules"
  [[ -s $autodetect_cache ]] && cat "$autodetect_cache"
  cleanup 0
fi

if [[ $preset ]]; then
  __build_preset "$preset"
else
  (( dryrun )) && info "Starting dry run"
  __build_image
fi

cleanup $?

