#!/bin/bash

shopt -s extglob

declare -A modquirks

# tender vittles
_sysconfdir=/etc
_sharedir=.
builderdir=${_sharedir}/builders
baseconfig=${_sysconfdir}/geninit.conf
carch=$(uname -m)
kernver=$(uname -r)

# declared as an array to force expansion. would be great if arch had
# symlink pointing to this from /lib/ld.so
ld_so=(/lib/ld-linux-${carch//_/-}.so.?*)

# Alter PATH. We want to make sure that /bin and /sbin are favored, since
# we specifically rely on GNU coreutils
PATH=/sbin:/bin:$PATH

# error codes
ENOENT=2
EACCES=13
EEXIST=17
EINVAL=22

# globals
declare -i automods=0
declare -i savefilelist=0
declare basedir=
declare config=
declare imagename=
declare preset=
declare skipbuilders=
declare ocompress=
declare dryrun=

# -------------------------- #
##  general util functions  ##
# -------------------------- #

err() { # {{{
  printf 'error: %s\n' "$*"
} >&2 # }}}

info() { # {{{
  printf ':: %s\n' "$*"
} # }}}

die() { # {{{
  err "$*"
  cleanup 1
} # }}}

in_array() { # {{{
  local item needle=$1; shift
  [[ -z $1 ]] && return 1 # Not Found

  for item; do
    [[ $item = $needle ]] && return 0 # Found
  done
  return 1 # Not Found
} # }}}

qgrep() { # {{{
  2>/dev/null grep -q "$@"
} # }}}

kmodinfo() { # {{{
  modinfo -0k $kernver "$@"
} # }}}

cleanup() { # {{{
  rm -rf "$tmpdir"
  exit $1
} # }}}

usage() { # {{{
  cat<<USAGE
geninit
Usage: geninit [options]

  Options:
   -b <path>      Use base directory (default: /)
   -c <file>      Specify a different config file (default: $_sysconfdir/geninit.conf)
   -g <path>      Path and name of generated image (dry-run if unspecified)
   -h             Display this help message
   -k <kver>      Specify a different kernel version (default: $(uname -r))
   -p <preset>    Build using a preset file
   -S <names>     Skip the specified builders during the build process
   -v             Output more
   -z <method>    Override compression method

USAGE
  exit
} # }}}

# --------------- #
##  private API  ##
# --------------- #

__add_file() { # {{{
  # add a file to cpio_filelist
  #   $1: pathname on initcpio
  #   $2: source on disk
  #   $3: mode

  # file <dest> <src> <mode> <uid> <gid> [<hard links>]

  (( $# == 3 )) || return $EINVAL

  qgrep "^file $1 " "$cpio_filelist" && return $EEXIST
  printf 'file %s %s %s 0 0\n' "$@" >>"$cpio_filelist"
} # }}}

__add_dir() { # {{{
  # add a directory to cpio_filelist (no knowledge of parents, use add_path instead)
  #   $1: pathname on initcpio
  #   $2: mode

  # dir <name> <mode> <uid> <gid>

  (( $# == 2 )) || [[ $1 == /?* ]] || return $EINVAL

  local name=$1 mode=$2

  qgrep "^dir $name " "$cpio_filelist" && return $EEXIST
  printf 'dir %s %s 0 0\n' "$@" >>"$cpio_filelist"
} # }}}

__add_slink() { # {{{
  # add a symlink to cpio_filelist
  #   $1: name on initcpio
  #   $2: target of $1

  # slink <name> <target> <mode> <uid> <gid>

  (( $# == 2 )) || return $EINVAL

  local name=$1 target=$2

  qgrep "^slink $name " "$cpio_filelist" && return $EEXIST
  printf 'slink %s %s 777 0 0\n' "$name" "$target" >> "$cpio_filelist"
} # }}}

__add_pipe() { # {{{
  # add a pipe to cpio_filelist
  #   $1: pathname on initcpio
  #   $2: mode

  # pipe <name> <mode> <uid> <gid>

  (( $# == 2 )) || return $EINVAL

  local name=$1 mode=$2

  qgrep "^pipe $name " "$cpio_filelist" && return $EEXIST
  printf 'pipe %s %s 0 0\n' "$name" "$mode" >> "$cpio_filelist"
} # }}}

__add_sock() { # {{{
  # add a socket to cpio_filelist
  #   $1: pathname on initcpio
  #   $2: mode

  # sock <name> <mode> <uid> <gid>
  local name=$1 mode=$2

  qgrep "^sock $name " "$cpio_filelist" && return $EEXIST
  printf 'sock %s %s 0 0\n' "$name" "$mode" >> "$cpio_filelist"
} # }}}

__build_image() { # {{{
  declare -i modcount=0
  declare -a zopts pipesave
  declare builder= module= line= mod= file=

  # parse builder array
  for builder in "${builders[@]}"; do
    in_array "$builder" "${skipbuilders[@]}" && continue

    if [[ ! -f $builderdir/$builder ]]; then
      err "cannot find builder '$builder': No such file"
      continue
    fi

    # subshell to prevent namespace pollution
    . "$builderdir/$builder"
    if ! type -t build >/dev/null; then
      err "no build function found in builder '$builder'"
      continue
    fi

    info "Processing buildstep: [$builder]"
    build
  done

  # add extra modules from config
  for mod in ${modules[@]}; do
    add_module "$mod"
  done

  # add extra files from config
  for file in "${files[@]}"; do
    add_file "$file"
  done

  # generate depmod files
  info "Generating module dependencies"
  while read line; do
    if [[ $line =~ /lib/modules/[^[:space:]]+\.ko?(.gz) ]]; then
      module=${BASH_REMATCH[0]}
      install -Dm644 "$basedir$module" "$tmpdir$module"
      (( ++modcount ))
    fi
  done < "$cpio_filelist"

  if (( modcount )); then
    depmod -b "$tmpdir" "$kernver"
    for file in modules.{dep,alias,symbols}; do
      add_file "${tmpdir}${moduledir}/$file" "/lib/modules/$kernver/$file"
    done
  fi

  if (( savefilelist )); then
    imagename=${imagename:-image} # set during a dry-run
    if cp "$cpio_filelist" "/tmp/${imagename##*/}.filelist"; then
      info "image filelist saved to /tmp/${imagename##*/}.filelist"
    else
      err "failed to save filelist to /tmp" # should never happen
    fi
  fi

  if (( dryrun )); then
    info "Dry run complete. Use -g <path> to create an initramfs."
    cleanup 0
  fi

  if [[ $compress != cat ]]; then
    zopts=('-9')
    [[ $compress = xz ]] && zopts+=('--check=crc32')
  fi

  info "Creating$([[ $compress = cat ]] || printf " $compress") initramfs: $imagename"
  gen_init_cpio $cpio_filelist | "$compress" "${zopts[@]}" > "$imagename"
  pipesave=("${PIPESTATUS[@]}") # save immediately

  (( pipesave[0] )) && die "failed to create initramfs image"
  (( pipesave[1] )) && die "error compressing initramfs image"
  info "Image creation completed successfully"

  return $(( !!(pipesave[0] + pipesave[1]) ))
} # }}}

__build_preset() { # {{{
  local preset= presetfile=$_sysconfdir/geninit.d/$1.preset
  local -a presets

  if [[ ! -f $basedir$presetfile ]]; then
    err "preset not found: $1"
    return $ENOENT
  fi

  if ! . "$basedir$presetfile"; then
    err "failed to read preset: $1"
    return $EACCES
  fi

  local var= cfg= opts= imagename=

  # preset pulls in a known array 'presets'
  for preset in "${presets[@]}"; do
    # resolve kernel version
    if [[ -z $ALL_kver ]]; then
      err "No kernel version defined for preset \`$1'"
      return $EINVAL
    fi

    # resolve image name
    var=${preset}_image
    if [[ -z ${!var} ]]; then
      err "No imagename defined for preset \`$1'"
      return $EINVAL
    fi
    imagename=${!var}

    # extra config
    var=${preset}_config
    if [[ -z ${!var} ]]; then
      # fallback on $ALL_config if its available
      cfg=${ALL_config:-$_sysconfigdir/geninit.conf}
    else
      cfg=${!var}
    fi

    # extra options are optional
    var=${preset}_options
    opts=${!var}

    # this should always resolve to something (i hope)
    if [[ ! -f $basedir$cfg ]]; then
      err "preset config file not found: \`$basedir$cfg'"
      return $ENOENT
    fi

    # we've got enough to relaunch geninit now
    # TODO: don't relaunch. Do this the sane way.
    info "Building image from preset: $1-$preset"
    printf '  ==> %s\n' "-k $ALL_kver -c $cfg -g $basedir$imagename $opts"
    "$0" -b "$basedir" -k "$ALL_kver" -c "$cfg" -g "$basedir$imagename" $opts || return 1
    echo
  done
} # }}}

# its a trap!
trap 'cleanup 130' SIGINT
trap 'cleanup 143' SIGTERM

# source public API
. "$_sharedir/geninit.api"

# source module quirks file
. "$_sharedir/geninit.quirks"

# ------------------ #
##  option parsing  ##
# ------------------ #

while getopts ':b:c:g:hk:Mp:S:sz:' flag; do
  case $flag in
    b) basedir=$OPTARG ;;
    c) config=$OPTARG ;;
    g) imagename=$OPTARG ;;
    h) usage ;;
    k) kernver=$OPTARG ;;
    M) automods=1 ;;
    p) preset=$OPTARG ;;
    S) skipbuilders=(${OPTARG//,/ }) ;;
    s) savefilelist=1 ;;
    z) ocompress=$OPTARG ;; # named differently to allow overriding
    :) die "option requires an argument -- '$OPTARG'" ;;
   \?) die "invalid option -- '$OPTARG'" ;;
  esac
done

# ----------------- #
##  sanity checks  ##
# ----------------- #

# how did our ld.so resolution go?
if (( ${#ld_so[*]} != 1 )); then # uh oh...
  die "failed to resolve the location of /lib/ld.so. Please report this bug."
fi

# make sure our config exists, and source it
config=${config:-$baseconfig}
[[ ! -f $config ]] && die "failed to find config file: \`$config'" || . "$config"

# if specified, does the basedir exist? trim any trailing slash
if [[ $basedir ]]; then
  basedir=${basedir%/}
  [[ -d $basedir ]] || die "basedir \`$basedir' not found"
fi

# does the kernel exist inside the basedir?
[[ -d $basedir/lib/modules/$kernver ]] || die "kernel \`$kernver' not found"

# is our supplied compression method (if supplied) valid?
compress=${ocompress:-$compress}
if [[ -z $compress || $compress = none ]]; then
  compress=cat  # NOOP compressor
else
  [[ $compress = @(gzip|bzip2|lzma|xz) ]] || die "unknown compression method: $compress"
  type -P "$compress" >/dev/null || die "failed to find \`$compress' binary in PATH"
fi

# if $imagename is provided, its path needs to be valid
if [[ $imagename ]]; then
  imagepath=$(readlink -f "$imagename")
  [[ $imagepath ]] || die "invalid path to imagename: $imagename"
  [[ -w ${imagepath%/*} ]] || die "no permission to write to specified path: \`${imagepath%/*}'"
else # no $imagename, so we're doing a dry run
  dryrun=1
fi

# ------------ #
##  int main  ##
# ------------ #

# define a few paths for convenience
tmpdir=$(mktemp -d /tmp/${0##*/}.XXXXXX)
moduletmp=$tmpdir/modules
cpio_filelist=$tmpdir/cpiofilelist.$$
autodetect_cache=$tmpdir/autodetect.cache
moduledir=/lib/modules/$kernver

if (( automods )); then
  . "$_sharedir/builders/autodetect" || die "unable to source autodetect builder"
  build
  info "Autodetected modules"
  [[ -s $autodetect_cache ]] && cat "$autodetect_cache"
  cleanup 0
fi

(( dryrun )) && info "Starting dry run"
if [[ $preset ]]; then
  __build_preset "$preset"
else
  __build_image
fi

cleanup $?

