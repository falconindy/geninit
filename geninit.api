#!/bin/bash

#
# geninit public API
#
# To authors of builders:
#   these functions should be used over other functions in geninit such as
#   __add_file, which generally have no awareness of things such as $basedir or
#   $kernver.
#

shopt -s extglob

add_dir() { # {{{
  # add a directory (with parents)
  #   $1: absolute path on initcpio
  #   $2: mode (optional, defaults to 755)

  (( ! $# )) && return 1 # NOOP

  local path=$1 mode=${2:-755}

  __add_dir "$path" "$mode"
} # }}}

add_file() { # {{{
  # add a regular file. no parsing done.
  #   $1: source on disk
  #   $2: destination on initcpio (optional: assumes same as source)

  (( ! $# )) && return 1 # NOOP

  # determine source and destination
  local src=$basedir$1 dest=${2:-$1} mode=

  if [[ ! -f $src ]]; then
    err "$src: No such file"
    return 1
  fi

  mode=$(stat -c %a "$src")
  if [[ -z $mode ]]; then
    err "failed to stat file: \`$src'"
    return 1
  fi

  #add_path_to_file "$dest"

  __add_file "$dest" "$src" "$mode"
} # }}}

add_symlink() { # {{{
  # add a symlink
  #   $1: name on initcpio
  #   $2: target of $1

  (( $# != 2 )) || return 1

  add_path_to_file "$1"
  __add_slink "$@"
} # }}}

add_path_to_file() { # {{{
  # add the path leading up to a file
  #   $1: filename with full path
  [[ $1 ]] && add_dir "${1%/*}"
} # }}}

add_module() { # {{{
  # add a kernel module. deps are resolved recursively and added
  #   $1: kernel module by name (no path, with or without extension)

  local -a firmware moddeps
  local modpath= module= dep=

  module=${1%.ko?(.gz)}

  if [[ -z $basedir ]]; then # fast path =)
    read -rd '' modpath < <(kmodinfo -n "$module" 2>/dev/null)
  else # slow path =(
    read -rd '' modpath < <(find "$basedir$moduledir/kernel" -type f -name "$mod.ko" -o -name "$mod.ko.gz" -print0)
  fi

  [[ -z $modpath ]] && return 1

  add_file "$modpath" || return 1

  # grab firmware
  IFS=',' read -rd '' -a firmware < <(kmodinfo -F firmware "$modpath")
  for fw in "${firmware[@]}"; do
    add_file "/lib/firmware/$fw"
  done

  # resolve deps
  IFS=',' read -rd '' -a moddeps < <(kmodinfo -F depends "$modpath")
  for dep in "${moddeps[@]}"; do
    add_module "$dep"
  done

  # add in any quirks
  for mod in ${modquirks[$module]}; do
    add_module "$mod"
  done

  return 0
} # }}}

add_binary() { # {{{
  # comment goes here
  # this needs reworking to use $basedir

  [[ -f $basedir$1 ]] || { err "$1 not found"; return 1; }

  local -a sodeps
  local binary=$basedir$1 sodep= resolved=

  if ! "$ld_so" --verify "$binary"; then
    # this isn't a binary!
    add_file "$binary"
    return $? # return with add_file's return val
  fi

  IFS=$'\n' read -rd '' -a sodeps < <(ldd "$basedir$1" |\
      sed -n '2,$s#.\+=>[[:blank:]]\+\([^ ]\+\) (.\+#\1#p')

  for sodep in "${sodeps[@]}"; do
    [[ -e $sodep ]] || continue

    if [[ -f $sodep ]]; then # but wait! a symlink is a regular file! FFFUUUUU
      if [[ ! -L $sodep ]]; then
        add_file "$sodep"
      else
        resolved="$(readlink -e "$sodep")"
        __add_dir "${resolved%/*}" 755
        __add_slink "$sodep" "$resolved"
        add_file "$resolved"
      fi
    fi
  done

  # the binary itself
  add_file "$basedir$1" "${2:-$1}"

  # we always need the big bad linker
  __add_slink "$ld_so" $(readlink -e "$ld_so")
  add_file "$(readlink -e "$ld_so")"
} # }}}

add_pipe() {
  # IOU: one pipe adding function
  :
}

use_hookscript() { # {{{
  # specifies that a builder should install a hookscript
  # $builder comes from the builder parsing loop in main

  [[ $builder ]] || return 1
  add_file "$basedir$_sharedir/hooks/$builder" "/hooks/$builder"
} # }}}

add_driver_classes() { # {{{
  local -a mods
  local -i ret=0
  local mod=

  # find modules by class (e.g. drivers/ata)
  pushd "$moduledir/kernel" &>/dev/null
  while read -rd '' mod; do
    mod=${mod##*/}
    mods+=("${mod%.ko?(.gz)}")
  done < <(find "$@" -type f \( -name '*.ko' -o -name '*.ko.gz' \) -print0 2>/dev/null)
  popd &>/dev/null

  # only add what autodetect found if we have a module cache
  [[ -s $autodetect_cache ]] &&
    IFS=$'\n' read -rd '' -a mods < <(grep -xf <(printf '%s\n' "${mods[@]//-/_}") "$autodetect_cache")

  for mod in "${mods[@]}"; do
    add_module "$mod" && (( ++ret ))
  done

  # return 0 on modules added, else 1
  return $(( ! ret ))
} # }}}

